import { createMachine, assign, send } from 'xstate';
import { getCardsToReview, tomorrow } from './utilities';
export const transitions = {
  START: 'START',
  REVIEWED: 'NEXT_CARD',
  API_RESPONSE: 'API_RESPONSE',
};

export const states = {
  intro: 'intro',
  review: 'review',
  loading: 'loading',
  summary: 'summary',
};

export const flashCardMachine = createMachine(
  {
    id: 'flashcard',
    predictableActionArguments: true,
    initial: states.intro,
    context: {
      // Functions
      cardFinishCallback: ({ context, event }) => {
        debugger
        return Promise.resolve({ context, event })
      },
      getDrawPileCallack: ({ context, event }) => ({ context, event }) => {
        debugger
        const { cards, currentCardIndex } = context
        return cards.slice(currentCardIndex)
      }, 
      // State
      enableShuffle: true,
      currentCardIndex: 0,
      cards: [], // modified by the spaced repetition algorithm
      card: null,
      tableCards: [{key: 1}, { key: 2}],
      drawPile: [], // the list of cards sorted by the spaced repetition algorithm
    },
    states: {
      [states.intro]: {
        on: {
          [transitions.START]: {
            target: states.review,
          },
        },
      },
      [states.review]: {
        entry: ['dealCards', 'updateCards'], // modified to include updateCards action
        on: {
          [transitions.REVIEWED]: {
            target: states.loading,
          },
        },
      },
      [states.loading]: {
        invoke: {
          src: (context, event) => {
            return Promise.resolve({})
          },
          onDone: {
            actions: [
              send((context, event) => ({
                type: transitions.API_RESPONSE,
                ...event,
              })),
            ]
          },
        },
        on: {
          [transitions.API_RESPONSE]: [
            {
              target: states.summary,
              cond: 'allCardsScheduledPast3AM',
              actions: ['reviewCard'],
            },
            {
              target: states.review,
              actions: [
                'reviewCard',
                `incrementCard`,
              ],
            },
          ],
        },
      },
      [states.summary]: {
        entry: 'finishReview',
        type: 'final',
      },
    },
  },
  {
    actions: {
      finishReview: assign({
        tableCards: (context) => {
          return [
            ...context.tableCards.slice(0, context.currentCardIndex),
            { key: context.currentCardIndex + 1, summary: true, message: 'You have finished reviewing all your cards for today.' },
          ]
        }
      }),
      dealCards: assign((context, event) => {
        const cards = context.cards; // get the current list of cards from context
        const drawPile = context.getDrawPileCallack({ context, event }); // apply the algorithm
        const card = drawPile[0]; // get the next card to review
        return {
          ...context,
          card,
          drawPile,
          tableCards: [
            ...context.tableCards.slice(0, context.currentCardIndex),
            {...card, key: context.currentCardIndex + 1},
            {key: context.currentCardIndex + 2}
          ]
        }
      }),
      reviewCard: (context, event) => {
        console.log({ event })
        const card = context.card;
        card.addReview("good");
      },
      incrementCard: assign({
        currentCardIndex: (context) => context.currentCardIndex + 1,
      }),
      updateCards: assign({ // update the context.cards array with the sorted list
        cards: (context) => {
          debugger
          const drawPile = context.drawPile;
          if (!context.enableShuffle) {
            return drawPile
          }
          return drawPile.slice(1).concat(drawPile[0]);
        },
      }),
    },
    guards: {
      allCardsScheduledPast3AM: (context) => {
        return context.cards.every(card => card.dueDate.isAfter(tomorrow()));
      },
    },
  }
);
